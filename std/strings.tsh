func Index(s string, substr string) int {
	sul := len(substr)
	ind := -1

	for i := 0; i < len(s); i++ {
		j := 0

		for ; j < sul; j++ {
			si := i + j
			char := s[si]

			if s[i+j] != substr[j] {
				break
			}
		}

		if j == sul {
			ind = i
			break
		}
	}
	return ind
}

func Contains(s string, substr string) bool {
	return Index(s, substr) >= 0
}

func Join(elems []string, sep string) string {
	s := ""
	l := len(elems)

	for i := 0; i < l; i++ {
		s = s + elems[i]

		if i < (l - 1) {
			s = s + sep
		}
	}
	return s
}

func HasPrefix(s string, prefix string) bool {
	l := len(prefix)

	if len(s) >= l {
		return s[:l] == prefix
	}
	return false
}

func HasSuffix(s string, suffix string) bool {
	l := len(suffix)

	if len(s) >= l {
		l *= -1
		return s[l:] == suffix
	}
	return false
}

func Count(s string, substr string) int {
	lenS := len(s)
	lenSub := len(substr)

	if lenSub == 0 {
		return lenS + 1
	}
	c := 0

	for i := 0; i < lenS; {
		if HasPrefix(s[i:], substr) {
			c++
			i += lenSub
		} else {
			i++
		}
	}
	return c
}

func Split(s string, sep string) []string {
	sLen := len(s)
	sepLen := len(sep)
	elems := []string{}

	// If s and sep are empty, slice will be empty.
	if sLen > 0 || sepLen > 0 {
		startI := 0
		endI := 0
		elIndex := 0
		boundary := len(s)

		if sLen > 0 {
			boundary -= sepLen
		}

		for endI <= boundary {
			if s[endI:endI+sepLen] == sep {
				sepEmpty := sepLen == 0

				// If sep is empty, split after every char.
				if sepEmpty {
					endI++
				}

				if !sepEmpty || endI <= boundary {
					elems[elIndex] = s[startI:endI]
					endI += sepLen
					startI = endI
				}
				elIndex++
			} else if endI == boundary {
				// Add last element to slice.
				elems[elIndex] = s[startI:]
				break
			} else {
				endI++
			}
		}
	}
	return elems
}

func Repeat(s string, count int) string {
	new := s

	for i := 1; i < count; i++ {
		new += s
	}
	return new
}

func Replace(s string, old string, new string, n int) string {
	res := ""
	rep := 0
	i := 0
	lenOld := len(old)
	lenNew := len(new)

	if lenOld == 0 {
		res = new
		rep++
	}

	for i < len(s) && (rep < n || n < 0) {
		c := s[i]

		if lenOld == 0 {
			res += c + new
			i++
		} else if HasPrefix(s[i:], old) {
			res += new
			i += lenOld
		} else {
			res += c
			i++
			continue
		}
		rep++
	}
	return res + s[i:]
}

func ReplaceAll(s string, old string, new string) string {
	return Replace(s, old, new, -1)
}

func CutPrefix(s string, prefix string) (string, bool) {
	if HasPrefix(s, prefix) {
		return s[len(prefix):], true
	}
	return s, false
}

func CutSuffix(s string, suffix string) (string, bool) {
	if HasSuffix(s, suffix) {
		return s[0 : len(s)-len(suffix)], true
	}
	return s, false
}

func Cut(s string, sep string) (string, string, bool) {
	lenS := len(s)

	if lenS > 0 {
		i := Index(s, sep)

		if i >= 0 {
			return s[0:i], s[i+len(sep):], true
		}
	}
	return s, "", false
}

func TrimPrefix(s string, prefix string) string {
	s, c := CutPrefix(s, prefix)
	return s
}

func TrimSuffix(s string, suffix string) string {
	s, c := CutSuffix(s, suffix)
	return s
}

func TrimLeft(s string, cutset string) string {
	lenCS := len(cutset)

	if len(s) > 0 && lenCS > 0 {
		for {
			trimmed := false

			for i := 0; i < lenCS; i++ {
				lenS := len(s)
				sTemp, cut := CutPrefix(s, cutset[i])

				if cut {
					trimmed = true
					s = sTemp
				}
			}

			if !trimmed {
				break
			}
		}
	}
	return s
}

func TrimRight(s string, cutset string) string {
	lenCS := len(cutset)

	if len(s) > 0 && lenCS > 0 {
		for {
			trimmed := false

			for i := 0; i < lenCS; i++ {
				lenS := len(s)
				sTemp, cut := CutSuffix(s, cutset[i])

				if cut {
					trimmed = true
					s = sTemp
				}
			}

			if !trimmed {
				break
			}
		}
	}
	return s
}

func Trim(s string, cutset string) string {
	return TrimRight(TrimLeft(s, cutset), cutset)
}

func TrimSpace(s string) string {
	return Trim(s, "\t\n\v\f\r ")
}
